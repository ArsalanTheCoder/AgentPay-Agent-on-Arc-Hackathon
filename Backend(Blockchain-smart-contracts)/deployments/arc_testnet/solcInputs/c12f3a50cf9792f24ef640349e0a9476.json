{
  "language": "Solidity",
  "sources": {
    "src/arc.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\ninterface IERC20 {\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\r\n    function balanceOf(address account) external view returns (uint256);\r\n}\r\n\r\n\r\n/**\r\n * @title AgentPay Scheduled Payments\r\n * @notice Simple scheduled USDC payments on Arc blockchain\r\n * @dev AI agent creates multiple schedules for \"recurring\" effect\r\n */\r\ncontract AgentPayScheduledPayments {\r\n    \r\n    IERC20 public immutable USDC;\r\n\r\n    // Errors\r\n    error InvalidRecipient();\r\n    error InvalidAmount();\r\n    error InvalidDate();\r\n    error InsufficientBalance();\r\n    error TransferFailed();\r\n    error SubscriptionNotFound();\r\n    error NotYetDue();\r\n    error AlreadyPaid();\r\n    error Unauthorized();\r\n\r\n    // Events\r\n    event SubscriptionCreated(\r\n        uint256 indexed subscriptionId,\r\n        address indexed payer,\r\n        address indexed recipient,\r\n        uint256 amount,\r\n        uint256 paymentDate,\r\n        string description\r\n    );\r\n\r\n    event PaymentExecuted(\r\n        uint256 indexed subscriptionId,\r\n        address indexed payer,\r\n        address indexed recipient,\r\n        uint256 amount,\r\n        uint256 timestamp\r\n    );\r\n\r\n    event SubscriptionCancelled(\r\n        uint256 indexed subscriptionId,\r\n        address indexed payer\r\n    );\r\n\r\n    // Subscription Data\r\n    struct Subscription {\r\n        address payer;\r\n        address recipient;\r\n        uint256 amount;\r\n        uint256 paymentDate;\r\n        bool paid;\r\n        bool cancelled;\r\n        string description; // \"Netflix Nov 2025\"\r\n    }\r\n\r\n    // State\r\n    uint256 private subCounter;\r\n    mapping(uint256 => Subscription) public subscriptions;\r\n    mapping(address => uint256[]) public userSubscriptions;\r\n\r\n    // USDC ERC-20 contract on Arc Testnet\r\n    // Get actual address from: https://docs.arc.network/arc/references/contract-addresses\r\n    constructor(address _usdc) {\r\n        if (_usdc == address(0)) revert InvalidRecipient();\r\n        USDC = IERC20(_usdc);\r\n    }\r\n\r\n    /**\r\n     * @notice Create scheduled payment (AI creates multiple for \"recurring\")\r\n     * @param recipient Who receives the payment\r\n     * @param amount How much USDC to send\r\n     * @param paymentDate When to send (unix timestamp)\r\n     * @param description Payment description for receipts\r\n     * @return subscriptionId The created subscription ID\r\n     */\r\n    function schedulePayment(\r\n        address recipient,\r\n        uint256 amount,\r\n        uint256 paymentDate,\r\n        string calldata description\r\n    ) external returns (uint256 subscriptionId) {\r\n        // Validate inputs\r\n        if (recipient == address(0)) revert InvalidRecipient();\r\n        if (amount == 0) revert InvalidAmount();\r\n        if (paymentDate <= block.timestamp) revert InvalidDate();\r\n\r\n        // Create subscription\r\n        subCounter++;\r\n        subscriptionId = subCounter;\r\n\r\n        subscriptions[subscriptionId] = Subscription({\r\n            payer: msg.sender,\r\n            recipient: recipient,\r\n            amount: amount,\r\n            paymentDate: paymentDate,\r\n            paid: false,\r\n            cancelled: false,\r\n            description: description\r\n        });\r\n\r\n        userSubscriptions[msg.sender].push(subscriptionId);\r\n\r\n        emit SubscriptionCreated(\r\n            subscriptionId,\r\n            msg.sender,\r\n            recipient,\r\n            amount,\r\n            paymentDate,\r\n            description\r\n        );\r\n    }\r\n\r\n   function payNow(\r\n    address recipient,\r\n    uint256 amount,\r\n    string calldata description\r\n) external returns (uint256 subscriptionId) {\r\n    // Validate inputs\r\n    if (recipient == address(0)) revert InvalidRecipient();\r\n    if (amount == 0) revert InvalidAmount();\r\n\r\n    // Check balance\r\n    if (USDC.balanceOf(msg.sender) < amount) revert InsufficientBalance();\r\n\r\n    // Create subscription record\r\n    subCounter++;\r\n    subscriptionId = subCounter;\r\n\r\n    subscriptions[subscriptionId] = Subscription({\r\n        payer: msg.sender,\r\n        recipient: recipient,\r\n        amount: amount,\r\n        paymentDate: block.timestamp,\r\n        paid: true, // Marked as paid immediately\r\n        cancelled: false,\r\n        description: description\r\n    });\r\n\r\n    userSubscriptions[msg.sender].push(subscriptionId);\r\n\r\n    // Execute USDC transfer\r\n    bool success = USDC.transferFrom(msg.sender, recipient, amount);\r\n    if (!success) revert TransferFailed();\r\n\r\n    emit SubscriptionCreated(\r\n        subscriptionId,\r\n        msg.sender,\r\n        recipient,\r\n        amount,\r\n        block.timestamp,\r\n        description\r\n    );\r\n\r\n    emit PaymentExecuted(\r\n        subscriptionId,\r\n        msg.sender,\r\n        recipient,\r\n        amount,\r\n        block.timestamp\r\n    );\r\n}\r\n\r\n    /**\r\n     * @notice Execute the scheduled payment (anyone can call when due)\r\n     * @param subscriptionId The subscription to execute\r\n     */\r\n    function executePayment(uint256 subscriptionId) external {\r\n        Subscription storage sub = subscriptions[subscriptionId];\r\n\r\n        // Validate\r\n        if (sub.payer == address(0)) revert SubscriptionNotFound();\r\n        if (sub.paid) revert AlreadyPaid();\r\n        if (sub.cancelled) revert Unauthorized();\r\n        if (block.timestamp < sub.paymentDate) revert NotYetDue();\r\n\r\n        // Check balance\r\n        if (USDC.balanceOf(sub.payer) < sub.amount) revert InsufficientBalance();\r\n\r\n        // Mark as paid first (reentrancy protection)\r\n        sub.paid = true;\r\n\r\n        // Execute USDC transfer\r\n        bool success = USDC.transferFrom(sub.payer, sub.recipient, sub.amount);\r\n        if (!success) revert TransferFailed();\r\n\r\n        emit PaymentExecuted(\r\n            subscriptionId,\r\n            sub.payer,\r\n            sub.recipient,\r\n            sub.amount,\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Cancel a scheduled payment (only payer)\r\n     * @param subscriptionId The subscription to cancel\r\n     */\r\n    function cancelSubscription(uint256 subscriptionId) external {\r\n        Subscription storage sub = subscriptions[subscriptionId];\r\n\r\n        if (sub.payer == address(0)) revert SubscriptionNotFound();\r\n        if (sub.payer != msg.sender) revert Unauthorized();\r\n        if (sub.paid) revert AlreadyPaid();\r\n\r\n        sub.cancelled = true;\r\n\r\n        emit SubscriptionCancelled(subscriptionId, msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @notice Batch create multiple scheduled payments (for recurring setup)\r\n     * @param recipient Payment recipient\r\n     * @param amount Amount per payment\r\n     * @param startDate First payment date\r\n     * @param intervalDays Days between payments (30 = monthly)\r\n     * @param count How many payments to schedule\r\n     * @param description Base description\r\n     */\r\n    function batchSchedulePayments(\r\n        address recipient,\r\n        uint256 amount,\r\n        uint256 startDate,\r\n        uint256 intervalDays,\r\n        uint256 count,\r\n        string calldata description\r\n    ) external returns (uint256[] memory subscriptionIds) {\r\n        if (recipient == address(0)) revert InvalidRecipient();\r\n        if (amount == 0) revert InvalidAmount();\r\n        if (startDate <= block.timestamp) revert InvalidDate();\r\n        if (count == 0 || count > 24) revert InvalidAmount(); // Max 2 years\r\n\r\n        subscriptionIds = new uint256[](count);\r\n\r\n        for (uint256 i = 0; i < count; i++) {\r\n            subCounter++;\r\n            uint256 subId = subCounter;\r\n            uint256 paymentDate = startDate + (i * intervalDays * 1 days);\r\n\r\n            subscriptions[subId] = Subscription({\r\n                payer: msg.sender,\r\n                recipient: recipient,\r\n                amount: amount,\r\n                paymentDate: paymentDate,\r\n                paid: false,\r\n                cancelled: false,\r\n                description: string(abi.encodePacked(description, \" #\", _toString(i + 1)))\r\n            });\r\n\r\n            userSubscriptions[msg.sender].push(subId);\r\n            subscriptionIds[i] = subId;\r\n\r\n            emit SubscriptionCreated(\r\n                subId,\r\n                msg.sender,\r\n                recipient,\r\n                amount,\r\n                paymentDate,\r\n                subscriptions[subId].description\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Check if payment is ready to execute\r\n     */\r\n    function canExecute(uint256 subscriptionId) external view returns (bool) {\r\n        Subscription memory sub = subscriptions[subscriptionId];\r\n        \r\n        if (sub.payer == address(0) || sub.paid || sub.cancelled) return false;\r\n        return block.timestamp >= sub.paymentDate;\r\n    }\r\n\r\n    /**\r\n     * @notice Get subscription details\r\n     */\r\n    function getSubscription(uint256 subscriptionId) \r\n        external \r\n        view \r\n        returns (\r\n            address payer,\r\n            address recipient,\r\n            uint256 amount,\r\n            uint256 paymentDate,\r\n            bool paid,\r\n            bool cancelled,\r\n            string memory description\r\n        ) \r\n    {\r\n        Subscription memory sub = subscriptions[subscriptionId];\r\n        if (sub.payer == address(0)) revert SubscriptionNotFound();\r\n        \r\n        return (\r\n            sub.payer,\r\n            sub.recipient,\r\n            sub.amount,\r\n            sub.paymentDate,\r\n            sub.paid,\r\n            sub.cancelled,\r\n            sub.description\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Get all subscriptions for a user\r\n     */\r\n    function getUserSubscriptions(address user) external view returns (uint256[] memory) {\r\n        return userSubscriptions[user];\r\n    }\r\n\r\n    /**\r\n     * @notice Get pending (unpaid, uncancelled, due soon) subscriptions\r\n     */\r\n    function getPendingSubscriptions(address user) external view returns (uint256[] memory) {\r\n        uint256[] memory allSubs = userSubscriptions[user];\r\n        uint256 count = 0;\r\n\r\n        // Count pending\r\n        for (uint256 i = 0; i < allSubs.length; i++) {\r\n            Subscription memory sub = subscriptions[allSubs[i]];\r\n            if (!sub.paid && !sub.cancelled && block.timestamp >= sub.paymentDate) {\r\n                count++;\r\n            }\r\n        }\r\n\r\n        // Build array\r\n        uint256[] memory pending = new uint256[](count);\r\n        uint256 index = 0;\r\n        for (uint256 i = 0; i < allSubs.length; i++) {\r\n            Subscription memory sub = subscriptions[allSubs[i]];\r\n            if (!sub.paid && !sub.cancelled && block.timestamp >= sub.paymentDate) {\r\n                pending[index] = allSubs[i];\r\n                index++;\r\n            }\r\n        }\r\n\r\n        return pending;\r\n    }\r\n\r\n    /**\r\n     * @notice Get total subscriptions created\r\n     */\r\n    function getTotalSubscriptions() external view returns (uint256) {\r\n        return subCounter;\r\n    }\r\n\r\n    // Helper: uint to string\r\n    function _toString(uint256 value) internal pure returns (string memory) {\r\n        if (value == 0) return \"0\";\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        while (value != 0) {\r\n            digits -= 1;\r\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n            value /= 10;\r\n        }\r\n        return string(buffer);\r\n    }\r\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}